<?php
/*
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

############# Motto: "Looks are not all that important ...";
class Frontend extends ICommonExtension implements IFaceCommonConfigExtension {
    /* OBJECT: Identity */
    protected static $objName                   = 'Frontend :: RA PHP Framework';
    protected $objIdentificationString          = __CLASS__;

    /* RSS CONSTANTS */
    const RSS_CHANNEL                           = 'channel';
    const RSS_TITLE                             = 'title';
    const RSS_PUBLISHED_DATE                    = 'pubDate';
    const RSS_LINK                              = 'link';
    const RSS_DESCRIPTION                       = 'description';
    const RSS_ITEM                              = 'item';
    const RSS_GUID                              = 'guid';
    const RSS_ALTERNATE                         = 'alternate';
    const RSS_TYPE                              = 'application/rss+xml';

    /* XML SITEMAPs */
    const XML_URL                               = 'url';
    const XML_LOCATION                          = 'loc';
    const XML_LAST_MOD                          = 'lastmod';
    const XML_CHANGE_FREQ                       = 'changefreq';
    const XML_PRIORITY                          = 'priority';

    # CONSTRUCT;
    public function __construct () {
        // Construct any possible parent;
        parent::__construct ();
        // Do the tie ...
        $this->tieInCommonConfiguration ();

        // Set some requirements ...
        $this->objPathToSkinJSS = $this->getPathToSkinJSS ()->toRelativePath ();
        $this->objPathToSkinCSS = $this->getPathToSkinCSS ()->toRelativePath ();
    }

    /**
     * Will replace module tokens (also named table fields) that can be used independent of the table structure;
     *
     * This method, will replace a series of table field tokens, with their respective fields. This is to allow a better way to
     * write SQL conditions from the front-end of the module, that will interact perfectly with the back-end of the current module,
     * which should make the MVC pattern as pure as possible;
     *
     * @param S $objSQLParam The SQL string to be processed;
     * @return S Will return the current SQL string with modified tokens;
     */
    public function doModuleToken (S $objSQLParam) {
        // Set the tokens to be replaced;
        $objTokens = new A;

        // Set the replacements;
        $objReplac = new A;

        // Do a CALL to the parent, make it tokenize;
        return parent::doModuleTokens ($objTokens, $objReplac, $objSQLParam);
    }

    /**
     * Will add the administration menu;
     *
     * This method will tie in the current module with the administration module, while adding the proper administrator links. The
     * files to be required by the administration module are set in the configuration file of this module.
     *
     * @param IFaceAdministration $objAdministrationMech The administration object;
     * @return void Doesn't need to return anything;
     */
    public function tieInWithAdministration (IFaceAdministration $objAdministrationMech) {
        // Do the tie ...
        parent::tieInWithAdministration ($objAdministrationMech);

        // Do the administration menu;
    }

    /**
     * Will tie in with the authentication mechanism;
     *
     * This method will tie in with the authentication mechanism, making necessary zones, and binding this module with the
     * authentication module making necessary linkes along the way. For most of the time it's used as a mapping tool for the
     * default administrator group and necessary zones;
     *
     * @param IFaceAuthentication $objAuthenticationMech The authentication mechanism;
     */
    public function tieInWithAuthentication (IFaceAuthentication $objAuthenticationMech) {
        // Do a CALL to the parent;
        parent::tieInWithAuthentication ($objAuthenticationMech);
    }

    /**
     * Will do necessary URL routing and clean-up;
     *
     * While most of the times we will relly on static URLs, generated by our URL mechanism, most of the times we will need to be
     * able to modify the URL or redirect an user to a proper URL, if he has gone haywire. This method does just that, manages
     * the URL of the current requested page;
     */
    public function doURLRoutingAndCLEANUp () {
        // Redirect to HOME, if nothing set;
        if ($_GET->doCount ()->toInt () == 0) {
            // Set the header key and go home my man ...
            TPL::setHeaderStr (new S (HDR::HEADER_MOVED_PERMANENTLY));
            TPL::setHeaderKey (URL::rewriteURL (new A (Array (FRONTEND_SECTION_URL)),
            new A (Array (FRONTEND_HOME))), new S ('Location'));
        }

        // -- Fix the double www. and non-www;
        if (strpos (URL::rewriteURL (), '://www.') !== FALSE) {
            // Moved me permanently ...
            $this->setHeaderStr (new S (HDR::HEADER_MOVED_PERMANENTLY));
            $this->setHeaderKey (URL::rewriteURL ()
            ->doToken ('://www.', '://'), new S ('Location'));
        }

        // -- Fix the OLD to NEW moving of REWRITE_ENGINE;
        if (strpos ($_SERVER['REQUEST_URI'], 'index.php/') !== FALSE && REWRITE_ENGINE == TRUE) {
            // Moved me permanently ...
            $this->setHeaderStr (new S (HDR::HEADER_MOVED_PERMANENTLY));
            $this->setHeaderKey (URL::rewriteURL ()
            ->doToken ('index.php/', _NONE), new S ('Location'));
        }
    }

    /**
     * Will load default modules used in the frontend;
     *
     * This method will load all common and required modules (like authentication and settings) that are used commonly in the
     * frontend side of the application. It's a quick and easy way to separate module loading code, from changing day-to-day PHP
     * code that you will certainly modify from project to project;
     *
     * @return mixed Depends on end-user code and we cannot determine that permanently;
     */
    public function doModulesAndRequirements () {
        // Set the execution time stamp and document type;
        TPL::setExeTime (new S ('start'));

        // Set some requirements;
        $this->objSection = new A (Array (FRONTEND_SECTION_URL));
        $this->objURLImageDir = $this->getPathToSkinIMG ()->toRelativePath ();

        // And NOW, add those default CSS/JSS file we so desperatelly need for our everyday work ...
        TPL::manageJSS (new FilePath ('mnt/?js', FALSE), new S ('haveAMint'));
        TPL::manageJSS (new FilePath ($this->objPathToSkinJSS . 'jQuery/jQ.js'), new S ('jQ'));
        TPL::manageJSS (new FilePath ($this->objPathToSkinJSS . 'jQuery/jQUI.js'), new S ('jQUI'));
        TPL::manageJSS (new FilePath ($this->objPathToSkinJSS . 'jQuery/jQTimer.js'), new S ('jQTimer'));
        TPL::manageJSS (new FilePath ($this->objPathToSkinJSS . 'jQuery/jQClock.js'), new S ('jQClock'));
        TPL::manageJSS (new FilePath ($this->objPathToSkinJSS . 'jQuery/jQBind.js'), new S ('jQBind'));
        TPL::manageJSS (new FilePath ($this->objPathToSkinJSS . 'jQuery/jQUICheckbox.js'), new S ('jQUICR'));
        TPL::manageJSS (new FilePath ($this->objPathToSkinJSS . 'jQuery/jQFileStyle.js'),new S ('jQFStyle'));
        TPL::manageJSS (new FilePath ($this->objPathToSkinJSS . 'jQuery/jQToolTip.js'), new S ('jQTT'));
        TPL::manageJSS (new FilePath ($this->objPathToSkinJSS . 'jQuery/jQWidget.js'), new S ('jQWidget'));
        TPL::manageJSS (new FilePath ($this->objPathToSkinJSS . 'jQuery/jQContextMenu.js'), new S ('jQCM'));
        TPL::manageJSS (new FilePath ($this->objPathToSkinJSS . 'jQuery/jQEasing.js'), new S ('jQEasing'));
        TPL::manageJSS (new FilePath ($this->objPathToSkinJSS . 'jQuery/jQFancybox.js'), new S ('jQFancybox'));
        TPL::manageJSS (new FilePath ($this->objPathToSkinJSS . 'jQuery/jQScrollTo.Min.js'), new S ('jQScrollTo'));
        TPL::manageJSS (new FilePath ($this->objPathToSkinJSS . 'jQuery/jQExe.js'), new S ('jQExe'));
        TPL::manageCSS (new FilePath ($this->objPathToSkinJSS . 'jQuery/jQUI.css'), new S ('jQUICSS'));
        TPL::manageCSS (new FilePath ($this->objPathToSkinJSS . 'jQuery/jQContextMenu.css'), new S ('jQCM'));
        TPL::manageCSS (new FilePath ($this->objPathToSkinJSS . 'jQuery/jQFancybox.css'), new S ('jQFancybox'));

        // If we need to build the front-end, we need some requirements; Same for ALL ...
        $this->ATH = self::activateModule (new FilePath ('mod/authentication'), new B (TRUE));
        $this->STG = self::activateModule (new FilePath ('mod/settings'), new B (TRUE));
        $this->TXT = self::activateModule (new FilePath ('mod/texts'), new B (TRUE));

        // TIE'ins ...
        $this->ATH->tieInWithFrontend ($this);
        $this->TXT->tieInWithFrontend ($this);

        // Audio: If we have'em ... we should load'em ...
        if (self::checkModuleIsRegistered (new S ('mod/audio'))
        ->toBoolean () == TRUE) {
            // Yes, them modules are needed ...
            $this->AUD = self::activateModule (new FilePath ('mod/audio'), new B (TRUE));
            $this->AUD->tieInWithFrontend ($this);
        } else {
            if (isset ($_GET[FRONTEND_AUDIO_URL])) {
                $this->setHeaderKey (URL::staticURL (new A (Array (FRONTEND_ERROR_URL)),
                new A (Array ('404'))), new S ('Location'));
            }
        }

        // Articles: If we have'em ... we should load'em ...
        if (self::checkModuleIsRegistered (new S ('mod/articles'))
        ->toBoolean () == TRUE) {
            // Yes, them modules are needed ...
            $this->ART = self::activateModule (new FilePath ('mod/articles'), new B (TRUE));
            $this->ART->tieInWithFrontend ($this);
        } else {
            if (isset ($_GET[FRONTEND_ARTICLE_URL])) {
                $this->setHeaderKey (URL::staticURL (new A (Array (FRONTEND_ERROR_URL)),
                new A (Array ('404'))), new S ('Location'));
            }
        }

        // Contact: If we have'em ... we should load'em ...
        if (self::checkModuleIsRegistered (new S ('mod/contact'))
        ->toBoolean () == TRUE) {
            // Yes, them modules are needed ...
            $this->CNT = self::activateModule (new FilePath ('mod/contact'), new B (TRUE));
            $this->CNT->tieInWithFrontend ($this);
        } else {
            if (isset ($_GET[FRONTEND_CONTACT_URL])) {
                $this->setHeaderKey (URL::staticURL (new A (Array (FRONTEND_ERROR_URL)),
                new A (Array ('404'))), new S ('Location'));
            }
        }

        // Faq: Ok, sorry ... frequently asked questions ...
        if (self::checkModuleIsRegistered (new S ('mod/faq'))
        ->toBoolean () == TRUE) {
            // Yes, them modules are needed ...
            $this->FAQ = self::activateModule (new FilePath ('mod/faq'), new B (TRUE));
            $this->FAQ->tieInWithFrontend ($this);
        } else {
            if (isset ($_GET[FRONTEND_FAQ_URL])) {
                $this->setHeaderKey (URL::staticURL (new A (Array (FRONTEND_ERROR_URL)),
                new A (Array ('404'))), new S ('Location'));
            }
        }

        // Lyrics: Karaokeeeeeeeee man ...
        if (self::checkModuleIsRegistered (new S ('mod/lyrics'))
        ->toBoolean () == TRUE) {
            // Yes, them modules are needed ...
            $this->LRQ = self::activateModule (new FilePath ('mod/lyrics'), new B (TRUE));
            $this->LRQ->tieInWithFrontend ($this);
        } else {
            if (isset ($_GET[FRONTEND_LYRICS_URL])) {
                $this->setHeaderKey (URL::staticURL (new A (Array (FRONTEND_ERROR_URL)),
                new A (Array ('404'))), new S ('Location'));
            }
        }

        // Newsletter: Get me subscribed dude ...
        if (self::checkModuleIsRegistered (new S ('mod/newsletter'))
        ->toBoolean () == TRUE) {
            // Yes, them modules are needed ...
            $this->NLT = self::activateModule (new FilePath ('mod/newsletter'), new B (TRUE));
            $this->NLT->tieInWithFrontend ($this);
        } else {
            if (isset ($_GET[FRONTEND_NEWSLETTER_URL])) {
                $this->setHeaderKey (URL::staticURL (new A (Array (FRONTEND_ERROR_URL)),
                new A (Array ('404'))), new S ('Location'));
            }
        }

        // Products: Buy & Sell, bring me money ...
        if (self::checkModuleIsRegistered (new S ('mod/products'))
        ->toBoolean () == TRUE) {
            // Yes, them modules are needed ...
            $this->PRD = self::activateModule (new FilePath ('mod/products'), new B (TRUE));
            $this->PRD->tieInWithFrontend ($this);
        } else {
            if (isset ($_GET[FRONTEND_PRODUCTS_URL])) {
                $this->setHeaderKey (URL::staticURL (new A (Array (FRONTEND_ERROR_URL)),
                new A (Array ('404'))), new S ('Location'));
            }
        }
    }

    /**
     * Will request the header and enable common requirements through-out the frontend;
     *
     * This method will do the necessary header operations and management common for all the pages in our frontend. Usually, this
     * is the place where we will set all our CSS/JSS dependencies, activated cross-site modules and other such-kind of work. Thus
     * having one place to work with, gives us the full power of a clean-cut code;
     */
    public function doHeaderAndCommonRequirements () {
    	// Set some requirements;
    	$this->objBitmask = new A;
    	$tpF = new FilePath ($this->getPathToSkin ()
		->toRelativePath () . 'header.tp');

    	// Set them ALL to FALSE ...
    	for ($objI = 1; $objI <= 1; ++$objI) {
    		$this->objBitmask[$objI] = new B (FALSE);
    	}

    	// Now, make them TRUE ... whomever is OK ....
    	if ($_GET[FRONTEND_SECTION_URL] == FRONTEND_HOME)
    	$this->objBitmask[1] = new B (TRUE);

        ############ WIL'D CHANGE ############
        TPL::tpSet (URL::staticURL ($this->objSection, new A (Array (FRONTEND_HOME))), new S ('objURLHome'), $tpF);
        TPL::tpSet (URL::staticURL ($this->objSection, new A (Array (FRONTEND_ARTICLE_URL))), new S ('objURLNews'), $tpF);
        TPL::tpSet (URL::staticURL ($this->objSection, new A (Array (FRONTEND_CONTACT_URL))), new S ('objURLContact'), $tpF);
        TPL::tpSet (URL::staticURL ($this->objSection, new A (Array (FRONTEND_AUDIO_URL))), new S ('objURLAudio'), $tpF);
        TPL::tpSet (URL::staticURL ($this->objSection, new A (Array (FRONTEND_LYRICS_URL))), new S ('objURLLyrics'), $tpF);
        TPL::tpSet (URL::staticURL (new A (Array (FRONTEND_SECTION_URL, AUDIO_ACTION_URL)), new A (Array (FRONTEND_AUDIO_URL,
        AUDIO_UPLOAD_URL))), new S ('objURLUpload'), $tpF);

        ############ WON'T CHANGE ############
        TPL::tpSet ($this->objURLImageDir, new S ('objURLImageDir'), $tpF);
        TPL::tpSet ($this->objBitmask, new S ('objBitmask'), $tpF);
        TPL::tpSet ($this->AUD, new S ('AUD'), $tpF);
        TPL::tpSet ($this->TXT, new S ('TXT'), $tpF);
        TPL::tpSet ($this->ATH, new S ('ATH'), $tpF);
        TPL::tpExe ($tpF);
    }

    /**
     * Will execute the footer, and do additional clean-up that are common to the platform;
     *
     * This method will execute the necessary footer templates, and do clean-up operations common for the whole website. It's a
     * way to avoid having to write files with that code, and link'em in every page. We try to avoid such redundant operations as
     * much as we can, thus mappings like this are a good way to get to that ...
     */
    public function doFooterCommonRequirements () {
        // The TITLE, per-se ... as we need. It says who we are, what we do ...
        TPL::manageTTL ($this->STG->getConfigKey (new S ('settings_website_default_title')));

        // HTTP-EQUIVs ... as per HTTP/1.1
        TPL::manageEQV (new S ('Content-Type'), new S ('text/html; charset=UTF-8'));
        TPL::manageEQV (new S ('Content-Script-Type'), new S ('text/javascript'));
        TPL::manageEQV (new S ('Content-Style-Type'), new S ('text/css'));

        // Add'em defaults ... and specifics ... if they need to be added ...
        TPL::manageTAG (new S ('copyright'), new S ('KIT Software CAZ SRL on the RA PHP Framework code ONLY!'));
        TPL::manageTAG (new S ('author'), new S ('Catalin Alexandru Zamfir, KIT Software CAZ SRL'));
        TPL::manageTAG (new S ('generator'), new S ('RA PHP Framework.ro Platform'));
        TPL::manageTAg (new S ('robots'), new S ('index, follow'));
        TPL::manageTAG (new S ('revisit-after'), new S ('1 days'));

        // Google, Yahoo, MSN, RA PHP Framework WBMs ...
        TPL::manageTAG (new S ('y_key'), new S (YAHOO__WBM_KEY));
        TPL::manageTAG (new S ('verify-v1'), new S (GOOGLE_WBM_KEY));
        TPL::manageTAG (new S ('msvalidate.01'), new S (BING___WBM_KEY));
        TPL::manageTAG (new S ('ra_key'), new S (SHA1 (DOCUMENT_HOST)));

        // Add'em DEFAULTS ... forever ...
        TPL::manageCSS (new FilePath ($this
        ->objPathToSkinCSS . 'default.css'),
        new S ('default_css'));

        // Check for some IEs, Operas and others ...
        if ($this->getUserAgentProperty (new S ('browser')) == 'ie') {
            // Specific IE CSS (believe it ...)
            TPL::manageCSS (new FilePath ($this
            ->objPathToSkinCSS . 'default_ie.css'),
            new S ('default_ie'));

            // Specific IE jQuery JSS (ya! ...)
            TPL::manageJSS (new FilePath ($this
            ->objPathToSkinJSS . 'jQuery/jQExeIE.js'),
            new S ('jQExeIE'));
        }

        // Set the execution time ...
        TPL::setExeTime (new S ('finish'));
    }

    /**
     * Will execute the footer, and do additional clean-up;
     *
     * This method will execute the necessary footer templates, and do clean-up operations common for the whole website. It's a
     * way to avoid having to write files with that code, and link'em in every page. We try to avoid such redundant operations as
     * much as we can, thus mappings like this are a good way to get to that ...
     */
    public function doFooterAndCLEANUp () {
        // Set the template file ...
        $tpF = new FilePath ($this->getPathToSkin ()->toRelativePath () . 'footer.tp');

        ############ WI'DL CHANGE ############
        TPL::tpSet (URL::staticURL ($this->objSection, new A (Array (FRONTEND_CONTACT_URL))), new S ('objURLContact'), $tpF);
        TPL::tpSet (URL::staticURL ($this->objSection, new A (Array (FRONTEND_FAQ_URL))), new S ('objURLFaq'), $tpF);
        TPL::tpSet (URL::staticURL ($this->objSection, new A (Array ('Termeni-si-conditii'))), new S ('objURLTerms'), $tpF);
        TPL::tpSet (URL::staticURL ($this->objSection, new A (Array ('Act-de-renuntare'))), new S ('objURLDisclaimer'), $tpF);
        TPL::tpSet (URL::staticURL ($this->objSection, new A (Array ('Politica-de-confidentialitate'))), new S ('objURLPP'), $tpF);

        ############ WON'T CHANGE ############
        TPL::tpSet (new F (TPL::getExeTime (new S ('start'), new S ('finish'))), new S ('objGenerationTime'), $tpF);
        TPL::tpSet ($this->objURLImageDir, new S ('objURLImageDir'), $tpF);
        TPL::tpSet ($this->TXT, new S ('TXT'), $tpF);
        TPL::tpExe ($tpF);
    }

    /**
     * Will do all necessary operations to enable the front-end pages;
     *
     * This method will do all necessary operations and requirements to render the front-end pages, we give by the parameter, or
     * similar parameter. It's an easy way to consider this module as the front-end part of the website. Many times you will find
     * that a module-based approach is best in comparison to a file-controller based one.
     */
    public function doTieALLNecessaryRequirementsAndRenderFrontend () {
        // Make defaults for common purposes;
        $this->doURLRoutingAndCLEANUp ();
        $this->doModulesAndRequirements ();
        $this->doHeaderAndCommonRequirements ();

        // Do render ERROR pages;
        if (isset ($_GET[FRONTEND_ERROR_URL])) {
            // Make'em error'ed ...
            $this->renderFrontendPage ($_GET[FRONTEND_ERROR_URL],
            new S (FRONTEND_ERROR_URL));
        } else {
            // Make'em defaults, as per se ...
            if ($_GET[FRONTEND_SECTION_URL] instanceof S) {
                // Do a switch ...
                switch ($_GET[FRONTEND_SECTION_URL]) {
                    // Authentication ...
                    case FRONTEND_AUTHENTICATION_URL:
                        // Load needed modules ...
                        $this->renderFrontendPage ($_GET[FRONTEND_SECTION_URL],
                        new S (FRONTEND_AUTHENTICATION_URL));
                        break;

                    // Audio ... and related;
                    case FRONTEND_AUDIO_URL:
                        // Check'em ...
                        if ($this->AUD instanceof Nothing) {
                            // 404
                            $this->setHeaderKey (URL::staticURL (new A (Array (FRONTEND_ERROR_URL)),
                            new A (Array ('404'))), new S ('Location'));
                        } else {
                            // Load needed modules ...
                            $this->AUD->tieInWithAuthentication ($this->ATH);
                            $this->renderFrontendPage ($_GET[FRONTEND_SECTION_URL],
                            new S (FRONTEND_AUDIO_URL));
                        }
                        // BK;
                        break;

                    // Articles ...
                    case FRONTEND_ARTICLE_URL:
                        // Check'em ...
                        if ($this->ART instanceof Nothing) {
                            // 404
                            $this->setHeaderKey (URL::staticURL (new A (Array (FRONTEND_ERROR_URL)),
                            new A (Array ('404'))), new S ('Location'));
                        } else {
                            // Load needed modules ...
                            $this->ART->tieInWithAuthentication ($this->ATH);
                            $this->renderFrontendPage ($_GET[FRONTEND_SECTION_URL],
                            new S (FRONTEND_ARTICLE_URL));
                        }
                        // BK;
                        break;

                    // Contact ...
                    case FRONTEND_CONTACT_URL:
                        // Check'em ...
                        if ($this->CNT instanceof Nothing) {
                            // 404
                            $this->setHeaderKey (URL::staticURL (new A (Array (FRONTEND_ERROR_URL)),
                            new A (Array ('404'))), new S ('Location'));
                        } else {
                            // Load needed modules ...
                            $this->CNT->tieInWithAuthentication ($this->ATH);
                            $this->renderFrontendPage ($_GET[FRONTEND_SECTION_URL],
                            new S (FRONTEND_CONTACT_URL));
                        }
                        // BK;
                        break;

                    // Faq ... you ...
                    case FRONTEND_FAQ_URL:
                        // Check'em ...
                        if ($this->FAQ instanceof Nothing) {
                            // 404
                            $this->setHeaderKey (URL::staticURL (new A (Array (FRONTEND_ERROR_URL)),
                            new A (Array ('404'))), new S ('Location'));
                        } else {
                            // Load needed modules ...
                            $this->FAQ->tieInWithAuthentication ($this->ATH);
                            $this->renderFrontendPage ($_GET[FRONTEND_SECTION_URL],
                            new S (FRONTEND_FAQ_URL));
                        }
                        // BK;
                        break;

                    // Lyrics ...
                    case FRONTEND_LYRICS_URL:
                        // Check'em ...
                        if ($this->LRQ instanceof Nothing) {
                            // 404
                            $this->setHeaderKey (URL::staticURL (new A (Array (FRONTEND_ERROR_URL)),
                            new A (Array ('404'))), new S ('Location'));
                        } else {
                            // Load needed modules ...
                            $this->LRQ->tieInWithAuthentication ($this->ATH);
                            $this->renderFrontendPage ($_GET[FRONTEND_SECTION_URL],
                            new S (FRONTEND_LYRICS_URL));
                        }
                        // BK;
                        break;

                    // Products: Buy & Sell ...
                    case FRONTEND_PRODUCTS_URL:
                        // Check'em ...
                        if ($this->PRD instanceof Nothing) {
                            // 404
                            $this->setHeaderKey (URL::staticURL (new A (Array (FRONTEND_ERROR_URL)),
                            new A (Array ('404'))), new S ('Location'));
                        } else {
                            // Load needed modules ...
                            $this->PRD->tieInWithAuthentication ($this->ATH);
                            $this->renderFrontendPage ($_GET[FRONTEND_SECTION_URL],
                            new S (FRONTEND_PRODUCTS_URL));
                        }
                        // BK;
                        break;

                    // TXTs ...
                    default:
                        // Load needed modules ...
                        $this->TXT->tieInWithAuthentication ($this->ATH);
                        $this->renderFrontendPage ($_GET[FRONTEND_SECTION_URL],
                        new S (FRONTEND_SECTION_URL));
                        break;

                    ################### RSS/XML Sitemap and feeds ###################
                    // RSS, XML ...
                    case FRONTEND_RSS_XML:
                        $this->renderFrontendPage ($_GET[FRONTEND_SECTION_URL],
                        new S (FRONTEND_RSS_XML));
                        break;

                    // XML Sitemap ...
                    case FRONTEND_STE_MAP:
                        $this->renderFrontendPage ($_GET[FRONTEND_SECTION_URL],
                        new S (FRONTEND_STE_MAP));
                        break;
                }
            } else {
                // 404
                $this->setHeaderKey (URL::staticURL (new A (Array (FRONTEND_ERROR_URL)),
                new A (Array ('404'))), new S ('Location'));
            }
        }

        // Footers & CLEAN-Up;
        $this->doFooterCommonRequirements ();
        $this->doFooterAndCLEANUp ();
    }

    #################################################### THESE WON'T CHANGE ####################################################

    /**
     * Will set the pagination, if needed. We use a common method for ALL, because usually (just usually) the pagination's the same
     * almost everywhere ...
     *
     * This method will call the necesary pagination code, while given an item count. This way all the pagination can be done
     * in one places, all pagination bugs can be fixed in one place, and we're actually a little closer to having non-redundant
     * code standing around ...
     */
    public function setPagination (I $objItemCount, I $objItemPerPage) {
        // Set the template file ...
        $tpF = new FilePath ($this->getPathToSkin ()->toRelativePath () . 'itemPagination.tp');
        TPL::tpSet ($objItemPerPage, new S ('objArticleTablePerPage'), $tpF);
        TPL::tpSet ($objItemCount, new S ('objArticleTableCount'), $tpF);
        TPL::tpExe ($tpF);
    }

    /**
     * Will __CALL the proper methods;
     *
     * This method will call the proper methods, that aren't defined as self-standing methods, but are defined as cases in a
     * switch statement in this method. We do this because some of the functions here, due to our style of programming, share
     * many repetitive configuration options, meaning that for an action, we only write the code once, and if we need to
     * modify something somewhere, than we know exactly where to find it;
     *
     * Another argument is that for the moment no inheritance is really needed. Besides that, we could simulate inheritance by
     * doing a default CALL to the parent method, which means that if there wasn't any case that matched the current object scope,
     * than the calling function will be passed up the parent. It's a nice way of having extremely organized code, while keeping
     * the advantages of an almost full OOP programming style, without loss in performance;
     */
    public function __CALL ($objFunctionName, $objFunctionArgs) {
        switch ($objFunctionName) {
            default:
                return parent::__CALL ($objFunctionName, $objFunctionArgs);
                break;
        }
    }

    /**
     * Will render a requested widget;
     *
     * This method is used to render a widget that usually is used in the frontend part of any website done with the help of this
     * platform. What are widgets you ask?! Well, it's quite simple. They are pieces of PHP code, usually tied to some
     * configuration options that control the way the widget functions or showns;
     *
     * Usually, configured widgets have enough power to be used in any way you want or need. For most of the times, the widgets
     * are called in the proper section of the frontend, but this method must permit the use of widgets, independent of the place
     * the developer needs them;
     *
     * @param $objW The widget to render;
     * @return mixed Depends on the widget;
     */
    public function renderWidget (S $objW, A $objWA = NULL) {
        // Make an empty array if NULL ...
        if ($objWA == NULL) $objWA = new A;

        // XML & RSS: Do a switch ...
        switch ($objW) {
            case AUTHENTICATION_YAHOO_BB_AUTH:
                require_once DOCUMENT_ROOT . _S . PLUGIN_DIR . _S . 'yahoo/ybrowserauth.class.php';
                $authObj = new YBBauthREST (APPID, SECRET);
                $objA = PARSE_URL ($_SERVER['REQUEST_URI']);

                if (isset ($objA['query'])) {
                    $objAuthURL = new S;
                    $objUserYML = new B (TRUE);
                    parse_str ($objA['query'], $objQ);
                    $authObj->token = $objQ['token'];
                    $objPath = 'http://address.yahooapis.com/api/ws/v1/searchContacts?format=xml';
                    $xmlstr = $authObj->makeAuthWSgetCall($objPath);
                    $xml = new SimpleXMLElement ($xmlstr);
                    $i = 0;
                    $objARM = new A;
                    foreach ($xml->contact as $contact) {
                        $objARM[$i] = new S ((string) $contact->yahooid);
                        if ($objARM[$i]->toLength ()->toInt () != 0) {
                            $objARM[$i] = $objARM[$i];
                            $i++;
                        }
                    }

                    $objEML = new MAIL;
                    $objEML->setFrom (new S ('24up! <office@24up.ro>'));
                    foreach ($objARM as $k => $v) {
                        $objEML->doMAIL (new S ($v . '@yahoo.com'), new S (FRONTEND_YAHOO_MAIL_SUBJECT),
                        $this->getHELP (new S ('widgetYahooInviteEMAIL')));
                    }
                } else {
                    $objAuthURL = new S ($authObj->getAuthURL('yahoo_auth_invite', true));
                    $objUserYML = new B (FALSE);
                }

                // Set the template file ...
                $tpF = new FilePath ($this->getPathToSkin ()
                ->toRelativePath () . 'users-yahoo-invite.tp');
                TPL::tpSet ($this->objURLImageDir,
                new S ('objURLImageDir'), $tpF);
                TPL::tpSet ($objUserYML, new S ('objUserYML'), $tpF);
                TPL::tpSet ($objAuthURL, new S ('objAuthURL'), $tpF);
                TPL::tpSet ($this->TXT, new S ('TXT'), $tpF);
                TPL::tpSet ($this->ATH, new S ('ATH'), $tpF);
                TPL::tpSet ($this->AUD, new S ('AUD'), $tpF);
                TPL::tpExe ($tpF);

                // TEMP fix;
                return TRUE;
                break;
        }
    }

    /**
     * Will render a specified form, the name of the form given by the first parameter;
     *
     * This method will render one of the forms for our object, invoked by giving the proper form identifier to the current form.
     * We have chosen this method of invoking forms, because we just had too many this->renderSomethingMethod (), which really had
     * an impact on code massiveness. Also, having code organized in switch/case statements leads us to be able to share common
     * settings between different forms, as we've done with the methods defined in the __CALL method above;
     *
     * For example, if we wanted to share some common configuration between a create and an edit form, we could have introduced
     * two switches in this method, one that would have set the common options, and the second, would have just passed through
     * again, and get the already set configuration options, using them. This means that if we needed to change behavior of
     * some interconnected forms, that would mean modifying the needed code one place only, which is a big advantage over
     * having separated methods for each form. Maybe if we extended this object, you guys could understand the functionality;
     *
     * @param string $objFormToRender The name of the form to render;
     * @return mixed Depends on the rendered form if it returns something or not;
     */
    public function renderBackendPage (S $objPageToRender) {
        // Get a specific CSS file for this controller ...
        TPL::manageCSS (new FilePath ($this->getPathToSkinCSS ()
        ->toRelativePath () . $objPageToRender . CSS_EXTENSION), $objPageToRender);

        // Do pagination ...
        if (isset ($_GET[ADMIN_PAGINATION])) {
            $objLowerLimit = (int) $_GET[ADMIN_PAGINATION]->toString () * 10 - 10;
            $objUpperLimit = 10;
        } else {
            $objLowerLimit = 0;
            $objUpperLimit = 10;
        }

        // Do a switch on the rendered page ...
        switch ($objPageToRender) {
            // Do;
        }
    }

    /**
     * Will render a specified form, the name of the form given by the first parameter;
     *
     * This method will render one of the forms for our object, invoked by giving the proper form identifier to the current form.
     * We have chosen this method of invoking forms, because we just had too many this->renderSomethingMethod (), which really had
     * an impact on code massiveness. Also, having code organized in switch/case statements leads us to be able to share common
     * settings between different forms, as we've done with the methods defined in the __CALL method above;
     *
     * For example, if we wanted to share some common configuration between a create and an edit form, we could have introduced
     * two switches in this method, one that would have set the common options, and the second, would have just passed through
     * again, and get the already set configuration options, using them. This means that if we needed to change behavior of
     * some interconnected forms, that would mean modifying the needed code one place only, which is a big advantage over
     * having separated methods for each form. Maybe if we extended this object, you guys could understand the functionality;
     *
     * @param string $objFormToRender The name of the form to render;
     * @return mixed Depends on the rendered form if it returns something or not;
     */
    public function renderFrontendPage (S $objPageToRender, S $objTypeSwitcher) {
        // Do a switch on the rendered page ...
        switch ($objTypeSwitcher) {
            // Authentication ... and stuff;
            case FRONTEND_AUTHENTICATION_URL:
                // Check the mighty authenticate ...
                if (isset ($_GET[AUTHENTICATION_ACTION_URL])) {
                    // Do a switch ...
                    switch ($_GET[AUTHENTICATION_ACTION_URL]) {
                        case AUTHENTICATION_REGISTER_URL:
                            // Set the template file ...
                            $tpF = new FilePath ($this->getPathToSkin ()
                            ->toRelativePath () . 'users-register.tp');
                            break;

                        case AUTHENTICATION_ACTIVATE_URL:
                            // Set the template file ...
                            $tpF = new FilePath ($this->getPathToSkin ()
                            ->toRelativePath () . 'users-activate.tp');
                            break;

                        case AUTHENTICATION_PROFILE_URL:
                            // Set the template file ...
                            $tpF = new FilePath ($this->getPathToSkin ()
                            ->toRelativePath () . 'users-profile.tp');
                            break;

                        case AUTHENTICATION_LOGOUT_URL:
                            // Log me OUT my wuv ...
                            $this->ATH->doLogOut ();

                            // Get me HOME ... I'm LOST here ...
                            $this->setHeaderKey (URL::staticURL (new A (Array (FRONTEND_SECTION_URL)),
                            new A (Array (FRONTEND_HOME))), new S ('Location'));
                            break;

                        case AUTHENTICATION_YAHOO_BB_AUTH:
                            return $this->renderWidget (new S (AUTHENTICATION_YAHOO_BB_AUTH));
                            break;
                    }
                } else {
                    // Set the template file ...
                    $tpF = new FilePath ($this->getPathToSkin ()
                    ->toRelativePath () . 'users.tp');
                }

                // Go my baby ... GO ...
                TPL::tpSet ($this->objURLImageDir,
                new S ('objURLImageDir'), $tpF);
                TPL::tpSet ($this->ATH, new S ('ATH'), $tpF);
                TPL::tpSet ($this->STG, new S ('STG'), $tpF);
                TPL::tpSet ($this->TXT, new S ('TXT'), $tpF);
                TPL::tpSet ($this->ART, new S ('ART'), $tpF);
                TPL::tpSet ($this->AUD, new S ('AUD'), $tpF);
                TPL::tpSet ($this->CNT, new S ('CNT'), $tpF);
                TPL::tpSet ($this->FAQ, new S ('FAQ'), $tpF);
                TPL::tpSet ($this->LRQ, new S ('LRQ'), $tpF);
                TPL::tpExe ($tpF);
                break;

            case FRONTEND_ARTICLE_URL:
                // Go my baby ... GO ...
                $tpF = new FilePath ($this->getPathToSkin ()
                ->toRelativePath () . 'news.tp');
                TPL::tpSet ($this->objURLImageDir,
                new S ('objURLImageDir'), $tpF);
                TPL::tpSet ($this->ATH, new S ('ATH'), $tpF);
                TPL::tpSet ($this->STG, new S ('STG'), $tpF);
                TPL::tpSet ($this->TXT, new S ('TXT'), $tpF);
                TPL::tpSet ($this->ART, new S ('ART'), $tpF);
                TPL::tpSet ($this->AUD, new S ('AUD'), $tpF);
                TPL::tpSet ($this->CNT, new S ('CNT'), $tpF);
                TPL::tpSet ($this->FAQ, new S ('FAQ'), $tpF);
                TPL::tpSet ($this->LRQ, new S ('LRQ'), $tpF);
                TPL::tpExe ($tpF);
                break;

            case FRONTEND_CONTACT_URL:
                // Go my baby ... GO ...
                $tpF = new FilePath ($this->getPathToSkin ()
                ->toRelativePath () . 'contact.tp');
                TPL::tpSet ($this->objURLImageDir,
                new S ('objURLImageDir'), $tpF);
                TPL::tpSet ($this->ATH, new S ('ATH'), $tpF);
                TPL::tpSet ($this->STG, new S ('STG'), $tpF);
                TPL::tpSet ($this->TXT, new S ('TXT'), $tpF);
                TPL::tpSet ($this->ART, new S ('ART'), $tpF);
                TPL::tpSet ($this->AUD, new S ('AUD'), $tpF);
                TPL::tpSet ($this->CNT, new S ('CNT'), $tpF);
                TPL::tpSet ($this->FAQ, new S ('FAQ'), $tpF);
                TPL::tpSet ($this->LRQ, new S ('LRQ'), $tpF);
                TPL::tpExe ($tpF);
                break;

            case FRONTEND_FAQ_URL:
                // Go my baby ... GO ...
                $tpF = new FilePath ($this->getPathToSkin ()
                ->toRelativePath () . 'faq.tp');
                TPL::tpSet ($this->objURLImageDir,
                new S ('objURLImageDir'), $tpF);
                TPL::tpSet ($this->ATH, new S ('ATH'), $tpF);
                TPL::tpSet ($this->STG, new S ('STG'), $tpF);
                TPL::tpSet ($this->TXT, new S ('TXT'), $tpF);
                TPL::tpSet ($this->ART, new S ('ART'), $tpF);
                TPL::tpSet ($this->AUD, new S ('AUD'), $tpF);
                TPL::tpSet ($this->CNT, new S ('CNT'), $tpF);
                TPL::tpSet ($this->FAQ, new S ('FAQ'), $tpF);
                TPL::tpSet ($this->LRQ, new S ('LRQ'), $tpF);
                TPL::tpExe ($tpF);
                break;

            case FRONTEND_LYRICS_URL:
                // Go my baby ... GO ...
                $tpF = new FilePath ($this->getPathToSkin ()
                ->toRelativePath () . 'lyrics.tp');
                TPL::tpSet ($this->objURLImageDir,
                new S ('objURLImageDir'), $tpF);
                TPL::tpSet ($this->ATH, new S ('ATH'), $tpF);
                TPL::tpSet ($this->STG, new S ('STG'), $tpF);
                TPL::tpSet ($this->TXT, new S ('TXT'), $tpF);
                TPL::tpSet ($this->ART, new S ('ART'), $tpF);
                TPL::tpSet ($this->AUD, new S ('AUD'), $tpF);
                TPL::tpSet ($this->CNT, new S ('CNT'), $tpF);
                TPL::tpSet ($this->FAQ, new S ('FAQ'), $tpF);
                TPL::tpSet ($this->LRQ, new S ('LRQ'), $tpF);
                TPL::tpExe ($tpF);
                break;

            case FRONTEND_AUDIO_URL:
                if (isset ($_GET[AUDIO_ACTION_URL])) {
                    // Do a switch ...
                    switch ($_GET[AUDIO_ACTION_URL]) {
                        case AUDIO_UPLOAD_URL:
                            // Set the template file ...
                            $tpF = new FilePath ($this->getPathToSkin ()
                            ->toRelativePath () . 'audio-upload.tp');
                            break;
                    }
                } else {
                    // Set the template file ...
                    $tpF = new FilePath ($this->getPathToSkin ()
                    ->toRelativePath () . 'audio.tp');
                }

                // Go my baby ... GO ...
                TPL::tpSet ($this->objURLImageDir,
                new S ('objURLImageDir'), $tpF);
                TPL::tpSet ($this->ATH, new S ('ATH'), $tpF);
                TPL::tpSet ($this->STG, new S ('STG'), $tpF);
                TPL::tpSet ($this->TXT, new S ('TXT'), $tpF);
                TPL::tpSet ($this->ART, new S ('ART'), $tpF);
                TPL::tpSet ($this->AUD, new S ('AUD'), $tpF);
                TPL::tpSet ($this->CNT, new S ('CNT'), $tpF);
                TPL::tpSet ($this->FAQ, new S ('FAQ'), $tpF);
                TPL::tpSet ($this->LRQ, new S ('LRQ'), $tpF);
                TPL::tpExe ($tpF);
                break;

            case FRONTEND_PRODUCTS_URL:
                // Go my baby ... GO ...
                $tpF = new FilePath ($this->getPathToSkin ()
                ->toRelativePath () . 'products.tp');
                TPL::tpSet ($this->objURLImageDir,
                new S ('objURLImageDir'), $tpF);
                TPL::tpSet ($this->ATH, new S ('ATH'), $tpF);
                TPL::tpSet ($this->STG, new S ('STG'), $tpF);
                TPL::tpSet ($this->TXT, new S ('TXT'), $tpF);
                TPL::tpSet ($this->ART, new S ('ART'), $tpF);
                TPL::tpSet ($this->AUD, new S ('AUD'), $tpF);
                TPL::tpSet ($this->CNT, new S ('CNT'), $tpF);
                TPL::tpSet ($this->FAQ, new S ('FAQ'), $tpF);
                TPL::tpSet ($this->PRD, new S ('PRD'), $tpF);
                TPL::tpSet ($this->LRQ, new S ('LRQ'), $tpF);
                TPL::tpExe ($tpF);
                break;

            // TXTs ... them defaults;
            case FRONTEND_SECTION_URL:
                // Do a switch ...
                switch ($_GET[FRONTEND_SECTION_URL]) {
                    case FRONTEND_HOME:
                        // Damn, you're good ...
                        $tpF = new FilePath ($this->getPathToSkin ()
                        ->toRelativePath () . 'home.tp');
                        break;

                    default:
                        // Get'em tiger ...
                        $tpF = new FilePath ($this->getPathToSkin ()
                        ->toRelativePath () . 'content.tp');
                        break;
                }

                // Go my baby ... GO ...
                TPL::tpSet ($this->objURLImageDir,
                new S ('objURLImageDir'), $tpF);
                TPL::tpSet ($this->ATH, new S ('ATH'), $tpF);
                TPL::tpSet ($this->STG, new S ('STG'), $tpF);
                TPL::tpSet ($this->TXT, new S ('TXT'), $tpF);
                TPL::tpSet ($this->ART, new S ('ART'), $tpF);
                TPL::tpSet ($this->AUD, new S ('AUD'), $tpF);
                TPL::tpSet ($this->CNT, new S ('CNT'), $tpF);
                TPL::tpSet ($this->FAQ, new S ('FAQ'), $tpF);
                TPL::tpSet ($this->LRQ, new S ('LRQ'), $tpF);
                TPL::tpExe ($tpF);
                break;

            ######################## THIS WILL NEVER - EVER - EVER - EVER - EVER - EVER CHANGE ########################
            // RSS Feeds ...
            case FRONTEND_RSS_XML:
                // Get the object ...
                $objRSS = TPL::getSitemapRSSOrXML (new S ('RSS'));
                $objDTE = date (DATE_RFC822, $_SERVER['REQUEST_TIME']);
                $objTTL = $this->STG->getConfigKey (new S ('settings_website_default_title'));
                $objXML = $objRSS->addCHILD (self::RSS_CHANNEL);
                $objXML->addCHILD (self::RSS_LINK, DOCUMENT_HOST);
                $objXML->addCHILD (self::RSS_PUBLISHED_DATE, $objDTE);
                $objXML->addCHILD (self::RSS_TITLE, $objTTL);
                $objXML->addCHILD (self::RSS_DESCRIPTION, $objTTL);

                // Go through ALL and XML my booty ... passed by reference ... yah baby!
                $this->AUD->renderWidget (new S ('widgetRSS'), new A (Array ('objXML' => $objXML)));
                $this->ART->renderWidget (new S ('widgetRSS'), new A (Array ('objXML' => $objXML)));
                $this->TXT->renderWidget (new S ('widgetRSS'), new A (Array ('objXML' => $objXML)));
                $this->PRD->renderWidget (new S ('widgetRSS'), new A (Array ('objXML' => $objXML)));

                // Do them XML ...
                TPL::outputXMLString (new S ($objRSS->asXML ()));
                break;

            // XML Sitemap ...
            case FRONTEND_STE_MAP:
                // Get the object ...
                $objXML = TPL::getSitemapRSSOrXML (new S ('MAP'));

                if (isset ($_GET['Type'])) {
                    switch ($_GET['Type']) {
                        case 'Lyrics':
                            $this->LRQ->renderWidget (new S ('widgetXML'),
                            new A (Array ('objXML' => $objXML, 'objId' => $_GET['Id'])));
                            break;
                    }
                } else {
                    // Go through ALL and XML my booty ... passed by reference ... yah baby!
                    $this->AUD->renderWidget (new S ('widgetXML'), new A (Array ('objXML' => $objXML)));
                    $this->ART->renderWidget (new S ('widgetXML'), new A (Array ('objXML' => $objXML)));
                    $this->TXT->renderWidget (new S ('widgetXML'), new A (Array ('objXML' => $objXML)));
                    $this->PRD->renderWidget (new S ('widgetXML'), new A (Array ('objXML' => $objXML)));
                }

                // Do them XML ...
                TPL::outputXMLString (new S ($objXML->asXML ()));
                break;

            // Errors ... (404, etc)
            case FRONTEND_ERROR_URL:
                // Check the code is defined ... or 404 if not ...
                if ($this->STG->checkErrorPageCodeIsUnique ($this->objCOD =
                $_GET[FRONTEND_ERROR_URL])->toBoolean () == TRUE)
                $this->setHeaderKey (URL::staticURL (new A (Array (FRONTEND_ERROR_URL)),
                new A (Array ('404'))), new S ('Location'));

                // Set some requirements ...
                $this->objCDE = $this->STG->getErrorPageByCode ($this->objCOD, Settings::$objSettingsErrTableFCode);
                $this->objTTL = $this->STG->getErrorPageByCode ($this->objCOD, Settings::$objSettingsErrTableFTitle);
                $this->objCNT = $this->STG->getErrorPageByCode ($this->objCOD, Settings::$objSettingsErrTableFContent);

                // Set the title ...
                TPL::manageTTL ($this->objCDE);
                TPL::manageTTL ($this->objTTL);

                // Set the template file ...
                $tpF = new FilePath ($this->getPathToSkin ()
                ->toRelativePath () . 'error.tp');
                TPL::tpSet ($this->objURLImageDir,
                new S ('objURLImageDir'), $tpF);

                // Set'em vars ...
                TPL::tpSet ($this->objCNT, new S ('objCNT'), $tpF);
                TPL::tpSet ($this->objTTL, new S ('objTTL'), $tpF);
                TPL::tpSet ($this->objCDE, new S ('objCDE'), $tpF);
                TPL::tpSet ($this->ATH, new S ('ATH'), $tpF);
                TPL::tpSet ($this->STG, new S ('STG'), $tpF);
                TPL::tpSet ($this->TXT, new S ('TXT'), $tpF);
                TPL::tpSet ($this->ART, new S ('ART'), $tpF);
                TPL::tpSet ($this->AUD, new S ('AUD'), $tpF);
                TPL::tpSet ($this->CNT, new S ('CNT'), $tpF);
                TPL::tpSet ($this->FAQ, new S ('FAQ'), $tpF);
                TPL::tpExe ($tpF);
                break;
        }
    }

    /**
     * Will render a specified form, the name of the form given by the first parameter;
     *
     * This method will render one of the forms for our object, invoked by giving the proper form identifier to the current form. We
     * have chosen this method of invoking forms, because we just had too many this->renderSomethingMethod (), which really had
     * an impact on code massiveness. Also, having code organized in switch/case statements leads us to be able to share common
     * settings between different forms, as we've done with the methods defined in the __CALL method above;
     *
     * For example, if we wanted to share some common configuration between a create and an edit form, we could have introduced
     * two switches in this method, one that would have set the common options, and the second, would have just passed through
     * again, and get the already set configuration options, using them. This means that if we needed to change behavior of
     * some interconnected forms, that would mean modifying the needed code one place only, which is a big advantage over
     * having separated methods for each form. Maybe if we extended this object, you guys could understand the functionality better;
     *
     * @param string $objFormToRender The name of the form to render;
     * @return mixed Depends on the rendered form if it returns something or not;
     */
    public function renderForm (S $objFormToRender) {
        switch ($objFormToRender) {
            // Do;
        }
    }
}
?>
